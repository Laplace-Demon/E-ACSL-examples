/* Generated by Frama-C */
#include "pthread.h"
#include "sched.h"
#include "signal.h"
#include "stddef.h"
#include "stdint.h"
#include "stdio.h"
#include "time.h"
struct __e_acsl_mpz_struct {
   int _mp_alloc ;
   int _mp_size ;
   unsigned long *_mp_d ;
};
typedef struct __e_acsl_mpz_struct __e_acsl_mpz_struct;
typedef __e_acsl_mpz_struct ( __attribute__((__FC_BUILTIN__)) __e_acsl_mpz_t)[1];
struct __e_acsl_mpq_struct {
   __e_acsl_mpz_struct _mp_num ;
   __e_acsl_mpz_struct _mp_den ;
};
typedef struct __e_acsl_mpq_struct __e_acsl_mpq_struct;
typedef __e_acsl_mpq_struct ( __attribute__((__FC_BUILTIN__)) __e_acsl_mpq_t)[1];
typedef unsigned long __e_acsl_mp_bitcnt_t;
enum __e_acsl_assert_data_type_t {
    E_ACSL_INT = 0,
    E_ACSL_REAL = 1,
    E_ACSL_PTR = 2,
    E_ACSL_ARRAY = 3,
    E_ACSL_FUN = 4,
    E_ACSL_STRUCT = 5,
    E_ACSL_UNION = 6,
    E_ACSL_OTHER = 1000
};
typedef enum __e_acsl_assert_data_type_t __attribute__((__FC_BUILTIN__)) __e_acsl_assert_data_type_t;
enum __e_acsl_assert_data_ikind_t {
    E_ACSL_IBOOL = 0,
    E_ACSL_ICHAR = 1,
    E_ACSL_ISCHAR = 2,
    E_ACSL_IUCHAR = 3,
    E_ACSL_IINT = 4,
    E_ACSL_IUINT = 5,
    E_ACSL_ISHORT = 6,
    E_ACSL_IUSHORT = 7,
    E_ACSL_ILONG = 8,
    E_ACSL_IULONG = 9,
    E_ACSL_ILONGLONG = 10,
    E_ACSL_IULONGLONG = 11,
    E_ACSL_IMPZ = 12
};
typedef enum __e_acsl_assert_data_ikind_t __attribute__((__FC_BUILTIN__)) __e_acsl_assert_data_ikind_t;
enum __e_acsl_assert_data_rkind_t {
    E_ACSL_RFLOAT = 0,
    E_ACSL_RDOUBLE = 1,
    E_ACSL_RLONGDOUBLE = 2,
    E_ACSL_RMPQ = 3
};
typedef enum __e_acsl_assert_data_rkind_t __attribute__((__FC_BUILTIN__)) __e_acsl_assert_data_rkind_t;
union __e_acsl_assert_data_int_value_t {
   _Bool value_bool ;
   char value_char ;
   signed char value_schar ;
   unsigned char value_uchar ;
   int value_int ;
   unsigned int value_uint ;
   short value_short ;
   unsigned short value_ushort ;
   long value_long ;
   unsigned long value_ulong ;
   long long value_llong ;
   unsigned long long value_ullong ;
   struct __e_acsl_mpz_struct *value_mpz ;
};
typedef union __e_acsl_assert_data_int_value_t __attribute__((__FC_BUILTIN__)) __e_acsl_assert_data_int_value_t;
union __e_acsl_assert_data_real_value_t {
   float value_float ;
   double value_double ;
   long double value_ldouble ;
   struct __e_acsl_mpq_struct *value_mpq ;
};
typedef union __e_acsl_assert_data_real_value_t __attribute__((__FC_BUILTIN__)) __e_acsl_assert_data_real_value_t;
struct __e_acsl_assert_data_int_content_t {
   int is_enum ;
   __e_acsl_assert_data_ikind_t kind ;
   __e_acsl_assert_data_int_value_t value ;
};
typedef struct __e_acsl_assert_data_int_content_t __attribute__((__FC_BUILTIN__)) __e_acsl_assert_data_int_content_t;
struct __e_acsl_assert_data_real_content_t {
   __e_acsl_assert_data_rkind_t kind ;
   __e_acsl_assert_data_real_value_t value ;
};
typedef struct __e_acsl_assert_data_real_content_t __attribute__((__FC_BUILTIN__)) __e_acsl_assert_data_real_content_t;
union __e_acsl_assert_data_content_t {
   __e_acsl_assert_data_int_content_t int_content ;
   __e_acsl_assert_data_real_content_t real_content ;
   uintptr_t value_ptr ;
   uintptr_t value_array ;
};
typedef union __e_acsl_assert_data_content_t __attribute__((__FC_BUILTIN__)) __e_acsl_assert_data_content_t;
struct __e_acsl_assert_data_value_t {
   char const *name ;
   __e_acsl_assert_data_type_t type ;
   __e_acsl_assert_data_content_t content ;
   struct __e_acsl_assert_data_value_t *next ;
};
typedef struct __e_acsl_assert_data_value_t __attribute__((__FC_BUILTIN__)) __e_acsl_assert_data_value_t;
struct __e_acsl_assert_data_t {
   int blocking ;
   char const *kind ;
   char const *name ;
   char const *pred_txt ;
   char const *file ;
   char const *fct ;
   int line ;
   __e_acsl_assert_data_value_t *values ;
};
typedef struct __e_acsl_assert_data_t __attribute__((__FC_BUILTIN__)) __e_acsl_assert_data_t;
struct __e_acsl_contract_t;
typedef struct __e_acsl_contract_t __attribute__((__FC_BUILTIN__)) __e_acsl_contract_t;
/*@ ghost extern int __e_acsl_init; */

/*@ requires \valid_read(data) ∧ \initialized(data);
    assigns \nothing;
    
    behavior blocking:
      assumes data->blocking ≢ 0;
      requires predicate ≢ 0;
    
    behavior non_blocking:
      assumes data->blocking ≡ 0;
      check requires predicate ≢ 0;
    
    complete behaviors non_blocking, blocking;
    disjoint behaviors non_blocking, blocking;
 */
 __attribute__((__FC_BUILTIN__)) void __e_acsl_assert(int predicate,
                                                      __e_acsl_assert_data_t *data);

extern size_t __e_acsl_heap_allocation_size;

extern size_t __e_acsl_heap_allocated_blocks;

/*@ requires \valid(data);
    requires data->values ≡ \null ∨ \valid(data->values);
    assigns data->values;
    assigns data->values \from (indirect: __fc_heap_status), value;
 */
 __attribute__((__FC_BUILTIN__)) void __e_acsl_assert_register_int(__e_acsl_assert_data_t *data,
                                                                   char const *name,
                                                                   int is_enum,
                                                                   int value);

/*@ requires \valid(data);
    requires data->values ≡ \null ∨ \valid(data->values);
    assigns data->values;
    assigns data->values \from (indirect: __fc_heap_status), value;
 */
 __attribute__((__FC_BUILTIN__)) void __e_acsl_assert_register_ulong(
                                                                    __e_acsl_assert_data_t *data,
                                                                    char const *name,
                                                                    int is_enum,
                                                                    unsigned long value);

/*@ requires \valid(data);
    requires data->values ≡ \null ∨ \valid(data->values);
    assigns data->values;
    assigns data->values \from (indirect: __fc_heap_status), ptr;
 */
 __attribute__((__FC_BUILTIN__)) void __e_acsl_assert_register_ptr(__e_acsl_assert_data_t *data,
                                                                   char const *name,
                                                                   void *ptr);

/*@ requires \valid(data);
    assigns \nothing; */
 __attribute__((__FC_BUILTIN__)) void __e_acsl_assert_clean(__e_acsl_assert_data_t *data);

/*@ assigns \nothing; */
 __attribute__((__FC_BUILTIN__)) void __e_acsl_memory_init(int *argc_ref,
                                                           char ***argv,
                                                           size_t ptr_size);

/*@ assigns \nothing; */
 __attribute__((__FC_BUILTIN__)) void __e_acsl_memory_clean(void);

/*@ ensures \result ≡ \old(ptr);
    assigns \result;
    assigns \result \from *((char *)ptr + (0 .. size - 1)), ptr, size;
 */
 __attribute__((__FC_BUILTIN__)) void *__e_acsl_store_block(void *ptr,
                                                            size_t size);

/*@ assigns \nothing; */
 __attribute__((__FC_BUILTIN__)) void __e_acsl_delete_block(void *ptr);

/*@ assigns \result;
    assigns \result \from *((char *)ptr + (0 .. size - 1)), ptr, size;
    
    behavior valid:
      assumes \valid_read((char *)ptr + (0 .. size - 1));
      assumes
        size ≤ 0 ∨
        ¬\separated(
            (char *)ptr + (0 .. size - 1),
            (char *)\base_addr(base) + (0 .. \block_length(base) - 1)
            );
      ensures \result ≡ 1;
    
    behavior invalid_ptr:
      assumes ¬\valid_read((char *)ptr + (0 .. size - 1));
      ensures \result ≡ 0;
    
    behavior separated_ptr:
      assumes size > 0;
      assumes
        \separated(
          (char *)ptr + (0 .. size - 1),
          (char *)\base_addr(base) + (0 .. \block_length(base) - 1)
          );
      ensures \result ≡ 0;
    
    complete behaviors separated_ptr, invalid_ptr, valid;
    disjoint behaviors separated_ptr, invalid_ptr, valid;
 */
 __attribute__((__FC_BUILTIN__)) int __e_acsl_valid_read(void *ptr,
                                                         size_t size,
                                                         void *base,
                                                         void *addrof_base);

/*@ assigns \result;
    assigns \result \from *((char *)ptr + (0 .. size - 1)), ptr, size;
    
    behavior initialized:
      assumes \initialized((char *)ptr + (0 .. size - 1));
      ensures \result ≡ 1;
    
    behavior uninitialized:
      assumes ¬\initialized((char *)ptr + (0 .. size - 1));
      ensures \result ≡ 0;
    
    complete behaviors uninitialized, initialized;
    disjoint behaviors uninitialized, initialized;
 */
 __attribute__((__FC_BUILTIN__)) int __e_acsl_initialized(void *ptr,
                                                          size_t size);

long valid_nstring(char *s, long n, int wrtbl);

long valid_nwstring(wchar_t *s, long n, int wrtbl);

__inline static long valid_string__fc_inline(char *s, int wrtbl)
{
  long tmp;
  tmp = valid_nstring(s,(long)(-1),wrtbl);
  return tmp;
}

__inline static long valid_wstring__fc_inline(wchar_t *s, int wrtbl)
{
  long tmp;
  tmp = valid_nwstring(s,(long)(-1),wrtbl);
  return tmp;
}

extern  __attribute__((__FC_BUILTIN__)) int __e_acsl_sound_verdict;

int main(void)
{
  int __retres;
  int *p;
  int x;
  __e_acsl_memory_init((int *)0,(char ***)0,8UL);
  __e_acsl_store_block((void *)(& p),8UL);
  {
    int __gen_e_acsl_initialized;
    int __gen_e_acsl_and;
    __e_acsl_assert_data_t __gen_e_acsl_assert_data = {.values = (void *)0};
    __gen_e_acsl_initialized = __e_acsl_initialized((void *)(& p),
                                                    sizeof(int *));
    __e_acsl_assert_register_ptr(& __gen_e_acsl_assert_data,"&p",
                                 (void *)(& p));
    __e_acsl_assert_register_ulong(& __gen_e_acsl_assert_data,
                                   "sizeof(int *)",0,sizeof(int *));
    __e_acsl_assert_register_int(& __gen_e_acsl_assert_data,
                                 "\\initialized(&p)",0,
                                 __gen_e_acsl_initialized);
    if (__gen_e_acsl_initialized) {
      int __gen_e_acsl_valid_read;
      __gen_e_acsl_valid_read = __e_acsl_valid_read((void *)p,sizeof(int),
                                                    (void *)p,(void *)(& p));
      __e_acsl_assert_register_ptr(& __gen_e_acsl_assert_data,"p",(void *)p);
      __e_acsl_assert_register_ulong(& __gen_e_acsl_assert_data,
                                     "sizeof(int)",0,sizeof(int));
      __e_acsl_assert_register_int(& __gen_e_acsl_assert_data,
                                   "\\valid_read(p)",0,
                                   __gen_e_acsl_valid_read);
      __gen_e_acsl_and = __gen_e_acsl_valid_read;
    }
    else __gen_e_acsl_and = 0;
    __gen_e_acsl_assert_data.blocking = 1;
    __gen_e_acsl_assert_data.kind = "Assertion";
    __gen_e_acsl_assert_data.pred_txt = "\\valid_read(p)";
    __gen_e_acsl_assert_data.file = "uninitialized.c";
    __gen_e_acsl_assert_data.fct = "main";
    __gen_e_acsl_assert_data.line = 3;
    __gen_e_acsl_assert_data.name = "rte/mem_access";
    __e_acsl_assert(__gen_e_acsl_and,& __gen_e_acsl_assert_data);
    __e_acsl_assert_clean(& __gen_e_acsl_assert_data);
  }
  /*@ assert rte: mem_access: \valid_read(p); */
  x = *p;
  __retres = 0;
  __e_acsl_delete_block((void *)(& p));
  __e_acsl_memory_clean();
  return __retres;
}


